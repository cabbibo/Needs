<html>

<head>
  <style>

    html{ color:#fff; background:#000; }

    #container{
      width      : 100%;
      height     : 100%;
      position   : absolute;
      top        : 0px;
      left       : 0px;
      background : #000;
    }

    #stats{
      position  : absolute;
      bottom    : 0px;
      right     : 0px;
      z-index   : 999;
    }

    a{
color: #fff;
position: absolute;
z-index: 999;

    }
  </style>
</head>
<body>

  <div id="loading"> LOADING MODELS </div>

<script src = "lib/leap.js"                ></script>
<script src = "lib/underscore.js"      ></script>
<script src = "lib/three.js"               ></script>
<script src = "lib/jquery.min.js"          ></script>
<script src = "lib/stats.min.js"           ></script>
<script src = "lib/TrackballControls.js"   ></script>
<script src = "lib/ShaderLoader.js"        ></script>
<script src = "lib/OBJLoader.js"           ></script>
<script src = "lib/Stream.js"              ></script>
<script src = "lib/UserAudio.js"           ></script>
<script src = "lib/AudioController.js"     ></script>
<script src = "lib/AudioTexture.js"        ></script>
<script src = "lib/PhysicsRenderer.js"        ></script>


<script src = "js/Tendrils.js"        ></script>


<script>

  console.log('Loading');

  // Global Variables for THREE.JS
  var container , camera, scene, renderer , stats;

  // Global variable for leap
  var frame, controller;

  // Setting up how big we want the scene to be
  var sceneSize = 5000;

  var handGeo;
  var skullGeo;
  var tendrilGeo;

  var loaded = 0;
  var neededToLoad = 1;

  var tendrils;

  var TMP_VECTOR = new THREE.Vector3();
  var MAX_VEL = 100;

  var oCamPos = new THREE.Vector3();

  var clock = new THREE.Clock();


  var audioController = new AudioController();

  audioController.mute.gain.value = 0;

  var stream = new Stream(  '../audio/you.mp3',audioController  );

  var userMedia = new UserAudio( audioController );
  console.log( userMedia );

  userMedia.onStreamCreated = function(){
    onLoad();
  }
  
 /* var loader  = new THREE.OBJLoader();
  loader.load( 'models/Cab_Hand_TRIS.OBJ' , function( obj ){

    handGeo = obj.children[0].geometry//.geometry;
    console.log( handGeo );
    onLoad();

    handGeo.computeFaceNormals();
    handGeo.computeVertexNormals();

  });

  //Eye_ship_50k_tris.OBJ 
  //cyber_bug_Mk1_93k_tris.OBJ
  //totem_6.obj
  //skull1.obj

  loader.load( 'models/skull1.obj' , function( obj ){

    console.log( obj );
    skullGeo = obj.children[0].geometry//.geometry;
    console.log( skullGeo );

    console.log('ashasdsds');
    skullGeo.computeFaceNormals();
    skullGeo.computeVertexNormals();

    onLoad();

  });

  loader.load( 'models/Orb_seed_tris.OBJ' , function( obj ){

    console.log( obj );
    tendrilGeo = obj.children[0].geometry//.geometry;
    console.log(  );

    console.log('ashasdsds');
    tendrilGeo.computeFaceNormals();
    tendrilGeo.computeVertexNormals();

    onLoad();

  });*/

  var timer = { type:"f" , value:0 }
  var dT = { type:"f" , value:0 }

  var repelPositions = [];
  var repelVelocities = [];
  var repelRadii = [];
  var repelObjects = [];


 var shaders = new ShaderLoader('shaders');

  shaders.load( 'fs-fire' , 'fire' , 'fragment' );
  shaders.load( 'vs-fire' , 'fire' , 'vertex' );
  shaders.load( 'fs-uvIri' , 'uvIri' , 'fragment' );
  shaders.load( 'vs-uvIri' , 'uvIri' , 'vertex' );
  shaders.load( 'fs-planet' , 'planet' , 'fragment' );
  shaders.load( 'vs-planet' , 'planet' , 'vertex' );
  shaders.load( 'fs-tendril' , 'tendril' , 'fragment' );
  shaders.load( 'vs-tendril' , 'tendril' , 'vertex' );
  shaders.load( 'fs-tendrilLine' , 'tendrilLine' , 'fragment' );
  shaders.load( 'vs-tendrilLine' , 'tendrilLine' , 'vertex' );

  shaders.load( 'tendrilSim' , 'tendrilSim' , 'simulation' );
 
  shaders.shaderSetLoaded = function(){
   onLoad();
  }


  function init(){

    controller = new Leap.Controller();

    scene = new THREE.Scene();
    
    camera = new THREE.PerspectiveCamera( 
      50 ,
      window.innerWidth / window.innerHeight,
      sceneSize / 100 ,
      sceneSize * 40
    );

    // placing our camera position so it can see everything
    camera.position.z = sceneSize ;

    camera.velocity = new THREE.Vector3();

    controls = new THREE.TrackballControls( camera );

    // Getting the container in the right location
    container     = document.createElement( 'div' );
    container.id  = 'container';
    
    document.body.appendChild( container );


    // Getting the stats in the right position
    stats = new Stats();
    stats.domElement.id = 'stats';
    document.body.appendChild( stats.domElement );


    // Setting up our Renderer
    renderer = new THREE.WebGLRenderer();

    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );


    // Making sure our renderer is always the right size
    window.addEventListener( 'resize', onWindowResize , false );


    var light = new THREE.DirectionalLight( 0xaaaaff , 1);
    light.position.set( 0 , 0 , 1 );
    scene.add( light );

     var light = new THREE.DirectionalLight( 0xffaaaa , 1);
    light.position.set( 0 , 1 , 0 );
    scene.add( light );


     var light = new THREE.DirectionalLight( 0xaaffaa , 1);
    light.position.set( 1 , 0 , 0 );
    scene.add( light );

  
    var tNormal = THREE.ImageUtils.loadTexture( 'img/normals/moss_normal_map.jpg' );
    tNormal.wrapS = THREE.RepeatWrapping; 
    tNormal.wrapT = THREE.RepeatWrapping; 
    console.log( 'TNOMAL');
    console.log( tNormal );

    var t_iri = THREE.ImageUtils.loadTexture( 'img/iri/gold.png' );

    var color1 = new THREE.Vector3( 1. , 1. , .3 );
    var color2 = new THREE.Vector3( 5. , 2. , 0 );
    var color3 = new THREE.Vector3( 1. , .4 , 0. );
    var color4 = new THREE.Vector3( 1.8 , .4 , .0 );

    
    var uniforms = {

      lightPos: { type:"v3" , value: new THREE.Vector3(100,0,0)},
      tNormal:{type:"t",value:tNormal},
      time:timer,
      t_iri:{ type:"t" , value: t_iri},
      t_audio:{ type:"t" , value: audioController.texture },
      color1:{ type:"v3" , value: color1 },
      color2:{ type:"v3" , value: color2 },
      color3:{ type:"v3" , value: color3 },
      color4:{ type:"v3" , value: color4 },
      texScale:{type:"f" , value:.001},
      normalScale:{type:"f" , value:5.1}


    }



    vertexShader   = shaders.vertexShaders.planet;
    fragmentShader = shaders.fragmentShaders.planet;

    material = new THREE.ShaderMaterial({

      uniforms: uniforms,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader

    });

    var shinyMat = material;

  /*  mesh = new THREE.Mesh( handGeo , material );
    scene.add( mesh );

    mesh.scale.multiplyScalar( 4000.2 );

    mesh.rotation.x =  8.168140899333462;
    mesh.rotation.y = -5.654866776461628;
    mesh.rotation.z = 1.8849555921538759;

    mesh.position.x = -1000;
    mesh.position.y = -3000;

    handMesh = mesh;*/

   // var center = new THREE.Mesh( new THREE.IcosahedronGeometry( 40 , 0 ) , material );

   var tNormal = THREE.ImageUtils.loadTexture( 'img/normals/7723-normal.jpg' );
    tNormal.wrapS = THREE.RepeatWrapping; 
    tNormal.wrapT = THREE.RepeatWrapping; 
    console.log( 'TNOMAL');
    console.log( tNormal );

    var tLookup = THREE.ImageUtils.loadTexture( 'img/iriLookup.png' );

    var color1 = new THREE.Vector3( 1. , 1. , .3 );
    var color2 = new THREE.Vector3( 5. , 2. , 0 );
    var color3 = new THREE.Vector3( 1. , .4 , 0. );
    var color4 = new THREE.Vector3( 1.8 , .4 , .0 );

    
    var uniforms = {

      lightPos: { type:"v3" , value: new THREE.Vector3(100,0,0)},
      tNormal:{type:"t",value:tNormal},
      time:timer,
      tLookup:{ type:"t" , value: tLookup },
      t_audio:{ type:"t" , value: audioController.texture },
      color1:{ type:"v3" , value: color1 },
      color2:{ type:"v3" , value: color2 },
      color3:{ type:"v3" , value: color3 },
      color4:{ type:"v3" , value: color4 },
      texScale:{type:"f" , value:.001},
      normalScale:{type:"f" , value:.8}


    }



    vertexShader   = shaders.vertexShaders.uvIri;
    fragmentShader = shaders.fragmentShaders.uvIri;

    uvMat = new THREE.ShaderMaterial({

      uniforms: uniforms,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader

    });

    repelPositions.push( new THREE.Vector3() );
    repelVelocities.push( new THREE.Vector3() );
    repelRadii.push( 340 );

    var geo =  new THREE.CubeGeometry( 200 , 200 , 200 ) 
    var geo =  new THREE.IcosahedronGeometry( 200 , 2 ) 
    for( var i = 0; i< 10; i++ ){

        var repelObject = {}


        var theta = (i / 10) * 2 * Math.PI;

        var x = 1000 * Math.cos( theta );
        var z = 1000 * Math.sin( theta );

        repelObject.mesh = new THREE.Mesh( geo , uvMat );
        repelObject.velocity = new THREE.Vector3(
          ( Math.random() - .5 ) * 100,
          ( Math.random() - .5 ) * 100,
          ( Math.random() - .5 ) * 100
        );
        repelObject.position = new THREE.Vector3(
         x,//(Math.random() -.5 ) * 4000,
         0,//(Math.random() -.5 ) * 4000,
         z//(Math.random() -.5 )  * 4000
        );


        repelObject.mesh.rotation.y = -theta - Math.PI /2;
        repelObject.mesh.position = repelObject.position;

        repelObject.radius = 300;

        repelPositions.push(  repelObject.position );
        repelVelocities.push( repelObject.velocity );
        repelRadii.push(      repelObject.radius );

        repelObjects.push( repelObject );

        scene.add( repelObject.mesh );

      }

    //mesh.scale.multiplyScalar( 5.5 );
    //scene.add( mesh );
    
    /*var color4 = new THREE.Vector3( 1. , .1 , .3 );
    var color3 = new THREE.Vector3( 2. , .6 , .1 );
    var color2 = new THREE.Vector3( 1. , .1 , 0. );
    var color1 = new THREE.Vector3( 4. , 0. , .5 );*/


    /*var tNormal = THREE.ImageUtils.loadTexture( 'img/normals/ice-snow.jpg' );
    tNormal.wrapS = THREE.RepeatWrapping; 
    tNormal.wrapT = THREE.RepeatWrapping; 

    //tNormal.repeat.set( 40, 40 );
    //tNormal.needsUpdate = true;

    var t_iri = THREE.ImageUtils.loadTexture( '../img/iri/turq.png' );

    var uniforms = {

      lightPos: { type:"v3" , value: new THREE.Vector3(100,0,0)},
      tNormal:{type:"t",value:tNormal},
      time:timer,
      t_iri: { type:"t" , value: t_iri },
      tLookup:{ type:"t" , value: tLookup },
      t_audio:{ type:"t" , value: audioController.texture },
      color1:{ type:"v3" , value: color1 },
      color2:{ type:"v3" , value: color2 },
      color3:{ type:"v3" , value: color3 },
      color4:{ type:"v3" , value: color4 },
      texScale:{type:"f" , value:.01},
      normalScale:{type:"f" , value:1.5}

    }



    vertexShader   = shaders.vertexShaders.uvIri;
    fragmentShader = shaders.fragmentShaders.uvIri;

    material = new THREE.ShaderMaterial({

      uniforms: uniforms,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      side:THREE.DoubleSide

    });*/


  /*  mesh = new THREE.Mesh( skullGeo , material );// material );

    mesh.scale.multiplyScalar( 20.5 );

    mesh.position.x = -500;
    mesh.position.y = -5000;
    scene.add( mesh );


    var obj = new THREE.Object3D();

    for( var i =0 ; i < 8; i++ ){
      mesh = new THREE.Mesh( tendrilGeo , shinyMat );

      mesh.scale.multiplyScalar( 1000.5 );

      var theta = ( i/8 ) * 2 * Math.PI;
      mesh.position.x = 5000 * Math.cos( theta ); 
      mesh.position.z = 5000 * Math.sin( theta ); 
      mesh.rotation.z = -Math.PI/2;//2 * Math.PI * (i/8);
      mesh.rotation.y = -theta - Math.PI/2;
      
      obj.add( mesh );

    } 

    //obj.position.x = -500;
    obj.position.y = 5000;
    obj.rotation.x = -Math.PI / 20;

    scene.add( obj );*/



    tendrils = new Tendrils({

      repelPositions: repelPositions,
      repelVelocities: repelVelocities,
      repelRadii: repelRadii,
      
    });

    tendrils.activate();

    controller.connect();


  }


  function animate(){

    audioController.update();


    dT.value = clock.getDelta();
    timer.value += dT.value;

     for( var i = 0; i < repelObjects.length; i++ ){

        var rO = repelObjects[i];

        var force = new THREE.Vector3();

        
        for( var j = 0; j < repelObjects.length; j++ ){
          if( j != i ){


            var rO1 = repelObjects[j];

            TMP_VECTOR.copy( rO.position );
            TMP_VECTOR.sub( rO1.position );

            var l = TMP_VECTOR.length();
            TMP_VECTOR.normalize();

            TMP_VECTOR.multiplyScalar( l - 1000);
            force.sub( TMP_VECTOR.multiplyScalar( .001) );
            //var dif =  


          }
        }

        TMP_VECTOR.copy( rO.position );
        TMP_VECTOR.sub( new THREE.Vector3() );

        var l = TMP_VECTOR.length();
        force.sub(TMP_VECTOR.multiplyScalar( .000001 * l ) );

        rO.velocity.add( force );

        if( rO.position.length() < 300 ){

          rO.position.normalize();
          rO.position.multiplyScalar( 300 );

          rO.velocity.multiplyScalar( -1 );

        }

        if( rO.velocity.length() > MAX_VEL ){

          rO.velocity.normalize().multiplyScalar( MAX_VEL );

        }
        
       rO.position.add( rO.velocity );
       // rO.velocity.multiplyScalar( .99 );


      }



      oCamPos.copy( camera.position );

      controls.update();
      
      camera.velocity.copy( camera.position.clone().sub( oCamPos ) );



    //riggedSkeletons[ currentRiggedSkeleton ].update();

    tendrils.update();
    stats.update();

    renderer.render( scene , camera );

    requestAnimationFrame( animate );

  }

  // Resets the renderer to be the proper size
  function onWindowResize(){

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

  }

 /* function nextSkeleton(){

    riggedSkeletons[ currentRiggedSkeleton ].removeFromScene( scene );

    currentRiggedSkeleton ++;

    if( currentRiggedSkeleton === riggedSkeletons.length ){
      currentRiggedSkeleton = 0;
    }

    riggedSkeletons[ currentRiggedSkeleton ].addToScene( scene );

  }*/

  function onLoad(){


    loaded ++;

    if( loaded === neededToLoad ){

      init();
      animate();
      //stream.play();

    }

  }
</script>


</body>
</html>
